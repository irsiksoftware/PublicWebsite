{"version":3,"file":"js/tetris.cb9d18727a79ffb76b94.js","mappings":"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","sources":["webpack://testforai/./js/tetris.js"],"sourcesContent":["/**\r\n * Tetris Game - Movement Controls\r\n * Implements left, right, and down piece movement\r\n */\r\n\r\n// Game constants\r\nconst COLS = 10;\r\nconst ROWS = 20;\r\nconst BLOCK_SIZE = 32;\r\n\r\n// Game state\r\nlet canvas;\r\nlet ctx;\r\nlet previewCanvas;\r\nlet previewCtx;\r\nlet holdCanvas;\r\nlet holdCtx;\r\nlet currentPiece = null;\r\nlet nextPiece = null;\r\nlet heldPiece = null;\r\nlet canHold = true;\r\nlet board = [];\r\nlet gameState = {\r\n    score: 0,\r\n    level: 1,\r\n    lines: 0,\r\n    highScore: 0,\r\n    isPaused: false,\r\n    isGameOver: false\r\n};\r\nlet gameInterval = null;\r\nlet dropSpeed = 1000;\r\n\r\n// Initialize game\r\nfunction init() {\r\n    canvas = document.getElementById('tetris-game');\r\n    ctx = canvas.getContext('2d');\r\n\r\n    previewCanvas = document.getElementById('next-piece');\r\n    previewCtx = previewCanvas.getContext('2d');\r\n\r\n    holdCanvas = document.getElementById('hold-piece');\r\n    holdCtx = holdCanvas.getContext('2d');\r\n\r\n    // Load high score from localStorage\r\n    loadHighScore();\r\n\r\n    // Initialize board\r\n    board = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));\r\n\r\n    // Generate next piece\r\n    generateNextPiece();\r\n\r\n    // Spawn first piece\r\n    spawnPiece();\r\n\r\n    // Set up keyboard controls\r\n    document.addEventListener('keydown', handleKeyPress);\r\n\r\n    // Set up touch controls\r\n    setupTouchControls();\r\n\r\n    // Update UI\r\n    updateUI();\r\n\r\n    // Start game loop\r\n    startGameLoop();\r\n\r\n    // Initial draw\r\n    draw();\r\n    drawNextPiece();\r\n}\r\n\r\n// Generate next piece\r\nfunction generateNextPiece() {\r\n    const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];\r\n    const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];\r\n    const pieceData = TETROMINO_SHAPES[randomPiece];\r\n\r\n    nextPiece = {\r\n        shape: pieceData.rotations[0],\r\n        color: pieceData.color,\r\n        type: randomPiece\r\n    };\r\n}\r\n\r\n// Spawn new piece\r\nfunction spawnPiece() {\r\n    // Use the next piece as the current piece\r\n    currentPiece = {\r\n        x: Math.floor(COLS / 2) - 2,\r\n        y: 0,\r\n        shape: nextPiece.shape,\r\n        color: nextPiece.color,\r\n        type: nextPiece.type,\r\n        rotation: 0\r\n    };\r\n\r\n    // Generate new next piece\r\n    generateNextPiece();\r\n    drawNextPiece();\r\n\r\n    // Check if spawn position is valid\r\n    if (!canMove(currentPiece.x, currentPiece.y)) {\r\n        gameState.isGameOver = true;\r\n        stopGameLoop();\r\n    }\r\n}\r\n\r\n// Start game loop\r\nfunction startGameLoop() {\r\n    if (gameInterval) {\r\n        clearInterval(gameInterval);\r\n    }\r\n\r\n    dropSpeed = Math.max(100, 1000 - gameState.level * 50);\r\n    gameInterval = setInterval(gameTick, dropSpeed);\r\n}\r\n\r\n// Stop game loop\r\nfunction stopGameLoop() {\r\n    if (gameInterval) {\r\n        clearInterval(gameInterval);\r\n        gameInterval = null;\r\n    }\r\n}\r\n\r\n// Game tick - called every interval\r\nfunction gameTick() {\r\n    if (gameState.isPaused || gameState.isGameOver) {\r\n        return;\r\n    }\r\n\r\n    if (canMove(currentPiece.x, currentPiece.y + 1)) {\r\n        currentPiece.y++;\r\n    } else {\r\n        lockPiece();\r\n        clearLines();\r\n        spawnPiece();\r\n    }\r\n\r\n    draw();\r\n}\r\n\r\n// Lock piece to board\r\nfunction lockPiece() {\r\n    const shape = currentPiece.shape;\r\n\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                const y = currentPiece.y + row;\r\n                const x = currentPiece.x + col;\r\n\r\n                if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {\r\n                    board[y][x] = currentPiece.color;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Reset canHold when piece locks\r\n    canHold = true;\r\n}\r\n\r\n// Clear completed lines\r\nfunction clearLines() {\r\n    // Check all rows for completion\r\n    const fullRows = [];\r\n    for (let row = 0; row < ROWS; row++) {\r\n        if (board[row].every(cell => cell !== 0)) {\r\n            fullRows.push(row);\r\n        }\r\n    }\r\n\r\n    if (fullRows.length === 0) {\r\n        return;\r\n    }\r\n\r\n    // Flash rows briefly before clearing\r\n    flashRows(fullRows, () => {\r\n        // Remove cleared rows and shift blocks down\r\n        for (let i = fullRows.length - 1; i >= 0; i--) {\r\n            board.splice(fullRows[i], 1);\r\n            board.unshift(Array(COLS).fill(0));\r\n        }\r\n\r\n        // Update lines cleared count\r\n        gameState.lines += fullRows.length;\r\n\r\n        // Calculate score based on lines cleared\r\n        const lineScores = {\r\n            1: 100,\r\n            2: 300,\r\n            3: 500,\r\n            4: 800\r\n        };\r\n        gameState.score += (lineScores[fullRows.length] || 100) * gameState.level;\r\n\r\n        // Update high score\r\n        updateHighScore();\r\n\r\n        // Level up every 10 lines\r\n        const newLevel = Math.floor(gameState.lines / 10) + 1;\r\n        if (newLevel > gameState.level) {\r\n            gameState.level = newLevel;\r\n            startGameLoop(); // Restart loop with new speed\r\n        }\r\n\r\n        updateUI();\r\n        draw();\r\n    });\r\n}\r\n\r\n// Flash rows with color change animation\r\nfunction flashRows(rows, callback) {\r\n    const originalColors = [];\r\n\r\n    // Save original colors\r\n    for (const row of rows) {\r\n        originalColors.push([...board[row]]);\r\n    }\r\n\r\n    let flashCount = 0;\r\n    const maxFlashes = 3;\r\n    const flashInterval = 100; // ms\r\n\r\n    const flashTimer = setInterval(() => {\r\n        // Alternate between white and original colors\r\n        const useWhite = flashCount % 2 === 0;\r\n\r\n        for (const row of rows) {\r\n            for (let col = 0; col < COLS; col++) {\r\n                board[row][col] = useWhite ? '#ffffff' : originalColors[rows.indexOf(row)][col];\r\n            }\r\n        }\r\n\r\n        draw();\r\n        flashCount++;\r\n\r\n        if (flashCount >= maxFlashes * 2) {\r\n            clearInterval(flashTimer);\r\n            callback();\r\n        }\r\n    }, flashInterval);\r\n}\r\n\r\n// Load high score from localStorage\r\nfunction loadHighScore() {\r\n    const savedHighScore = localStorage.getItem('tetrisHighScore');\r\n    if (savedHighScore) {\r\n        gameState.highScore = parseInt(savedHighScore, 10);\r\n    }\r\n}\r\n\r\n// Update high score\r\nfunction updateHighScore() {\r\n    if (gameState.score > gameState.highScore) {\r\n        gameState.highScore = gameState.score;\r\n        localStorage.setItem('tetrisHighScore', gameState.highScore.toString());\r\n    }\r\n}\r\n\r\n// Update UI elements\r\nfunction updateUI() {\r\n    document.getElementById('score').textContent = gameState.score;\r\n    document.getElementById('level').textContent = gameState.level;\r\n    document.getElementById('lines').textContent = gameState.lines;\r\n    document.getElementById('high-score').textContent = gameState.highScore;\r\n}\r\n\r\n// Handle keyboard input\r\nfunction handleKeyPress(event) {\r\n    switch(event.key) {\r\n    case 'ArrowLeft':\r\n    case 'a':\r\n    case 'A':\r\n        moveLeft();\r\n        break;\r\n    case 'ArrowRight':\r\n    case 'd':\r\n    case 'D':\r\n        moveRight();\r\n        break;\r\n    case 'ArrowDown':\r\n    case 's':\r\n    case 'S':\r\n        moveDown();\r\n        break;\r\n    case 'ArrowUp':\r\n    case 'w':\r\n    case 'W':\r\n        rotatePiece();\r\n        break;\r\n    case 'c':\r\n    case 'C':\r\n        holdPiece();\r\n        break;\r\n    }\r\n}\r\n\r\n// Set up touch controls for mobile\r\nfunction setupTouchControls() {\r\n    const btnLeft = document.getElementById('btn-left');\r\n    const btnRight = document.getElementById('btn-right');\r\n    const btnDown = document.getElementById('btn-down');\r\n    const btnRotate = document.getElementById('btn-rotate');\r\n    const btnHold = document.getElementById('btn-hold');\r\n\r\n    // Prevent default touch behavior\r\n    const preventDefaultTouch = (e) => {\r\n        e.preventDefault();\r\n    };\r\n\r\n    // Left button\r\n    btnLeft.addEventListener('touchstart', (e) => {\r\n        preventDefaultTouch(e);\r\n        moveLeft();\r\n    });\r\n    btnLeft.addEventListener('click', () => {\r\n        moveLeft();\r\n    });\r\n\r\n    // Right button\r\n    btnRight.addEventListener('touchstart', (e) => {\r\n        preventDefaultTouch(e);\r\n        moveRight();\r\n    });\r\n    btnRight.addEventListener('click', () => {\r\n        moveRight();\r\n    });\r\n\r\n    // Down button\r\n    btnDown.addEventListener('touchstart', (e) => {\r\n        preventDefaultTouch(e);\r\n        moveDown();\r\n    });\r\n    btnDown.addEventListener('click', () => {\r\n        moveDown();\r\n    });\r\n\r\n    // Rotate button\r\n    btnRotate.addEventListener('touchstart', (e) => {\r\n        preventDefaultTouch(e);\r\n        rotatePiece();\r\n    });\r\n    btnRotate.addEventListener('click', () => {\r\n        rotatePiece();\r\n    });\r\n\r\n    // Hold button\r\n    btnHold.addEventListener('touchstart', (e) => {\r\n        preventDefaultTouch(e);\r\n        holdPiece();\r\n    });\r\n    btnHold.addEventListener('click', () => {\r\n        holdPiece();\r\n    });\r\n}\r\n\r\n// Move piece left\r\nfunction moveLeft() {\r\n    if (canMove(currentPiece.x - 1, currentPiece.y)) {\r\n        currentPiece.x--;\r\n        draw();\r\n    }\r\n}\r\n\r\n// Move piece right\r\nfunction moveRight() {\r\n    if (canMove(currentPiece.x + 1, currentPiece.y)) {\r\n        currentPiece.x++;\r\n        draw();\r\n    }\r\n}\r\n\r\n// Move piece down\r\nfunction moveDown() {\r\n    if (canMove(currentPiece.x, currentPiece.y + 1)) {\r\n        currentPiece.y++;\r\n        draw();\r\n    } else {\r\n        // Lock piece when collision detected on moveDown\r\n        lockPiece();\r\n        clearLines();\r\n        spawnPiece();\r\n        draw();\r\n    }\r\n}\r\n\r\n// Rotate piece with wall kicks (SRS standard)\r\nfunction rotatePiece() {\r\n    if (gameState.isPaused || gameState.isGameOver || !currentPiece) {\r\n        return;\r\n    }\r\n\r\n    const pieceData = TETROMINO_SHAPES[currentPiece.type];\r\n    const nextRotation = (currentPiece.rotation + 1) % 4;\r\n    const newShape = pieceData.rotations[nextRotation];\r\n\r\n    // Try rotation at current position\r\n    if (!checkCollision(currentPiece.x, currentPiece.y, newShape)) {\r\n        currentPiece.rotation = nextRotation;\r\n        currentPiece.shape = newShape;\r\n        draw();\r\n        return;\r\n    }\r\n\r\n    // Wall kick attempts: try offsets ±1, ±2\r\n    const wallKickOffsets = [1, -1, 2, -2];\r\n    for (const offset of wallKickOffsets) {\r\n        if (!checkCollision(currentPiece.x + offset, currentPiece.y, newShape)) {\r\n            currentPiece.x += offset;\r\n            currentPiece.rotation = nextRotation;\r\n            currentPiece.shape = newShape;\r\n            draw();\r\n            return;\r\n        }\r\n    }\r\n\r\n    // All kicks failed, don't rotate\r\n}\r\n\r\n// Check if piece can move to new position\r\nfunction canMove(newX, newY) {\r\n    const shape = currentPiece.shape;\r\n\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                const x = newX + col;\r\n                const y = newY + row;\r\n\r\n                // Check left boundary\r\n                if (x < 0) return false;\r\n\r\n                // Check right boundary\r\n                if (x >= COLS) return false;\r\n\r\n                // Check bottom boundary\r\n                if (y >= ROWS) return false;\r\n\r\n                // Check collision with locked pieces\r\n                if (y >= 0 && board[y][x] !== 0) return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Check collision at specific position with specific piece\r\nfunction checkCollision(x, y, piece) {\r\n    const shape = piece || currentPiece.shape;\r\n\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                const gridX = x + col;\r\n                const gridY = y + row;\r\n\r\n                // Check grid boundaries (0-9 for x, 0-19 for y)\r\n                if (gridX < 0 || gridX >= COLS) return true;\r\n                if (gridY < 0 || gridY >= ROWS) return true;\r\n\r\n                // Check if cell already occupied in grid\r\n                if (gridY >= 0 && board[gridY][gridX] !== 0) return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Draw grid borders and background\r\nfunction drawGrid() {\r\n    // Clear canvas\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Draw grid lines\r\n    ctx.strokeStyle = '#e0e0e0';\r\n    ctx.lineWidth = 1;\r\n    for (let row = 0; row <= ROWS; row++) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, row * BLOCK_SIZE);\r\n        ctx.lineTo(COLS * BLOCK_SIZE, row * BLOCK_SIZE);\r\n        ctx.stroke();\r\n    }\r\n    for (let col = 0; col <= COLS; col++) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(col * BLOCK_SIZE, 0);\r\n        ctx.lineTo(col * BLOCK_SIZE, ROWS * BLOCK_SIZE);\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\n// Draw the game\r\nfunction draw() {\r\n    // Clear and redraw grid\r\n    drawGrid();\r\n\r\n    // Draw locked pieces on board\r\n    for (let row = 0; row < ROWS; row++) {\r\n        for (let col = 0; col < COLS; col++) {\r\n            if (board[row][col] !== 0) {\r\n                ctx.fillStyle = board[row][col];\r\n                const x = col * BLOCK_SIZE;\r\n                const y = row * BLOCK_SIZE;\r\n\r\n                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);\r\n                ctx.strokeStyle = '#333333';\r\n                ctx.lineWidth = 2;\r\n                ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Draw current piece\r\n    if (currentPiece) {\r\n        ctx.fillStyle = currentPiece.color;\r\n        const shape = currentPiece.shape;\r\n\r\n        for (let row = 0; row < shape.length; row++) {\r\n            for (let col = 0; col < shape[row].length; col++) {\r\n                if (shape[row][col]) {\r\n                    const x = (currentPiece.x + col) * BLOCK_SIZE;\r\n                    const y = (currentPiece.y + row) * BLOCK_SIZE;\r\n\r\n                    ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);\r\n                    ctx.strokeStyle = '#333333';\r\n                    ctx.lineWidth = 2;\r\n                    ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Draw game over message\r\n    if (gameState.isGameOver) {\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n        ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);\r\n\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = '32px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);\r\n    }\r\n}\r\n\r\n// Draw next piece in preview canvas\r\nfunction drawNextPiece() {\r\n    // Clear preview canvas\r\n    previewCtx.fillStyle = '#ffffff';\r\n    previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);\r\n\r\n    if (!nextPiece) return;\r\n\r\n    const shape = nextPiece.shape;\r\n    const blockSize = 16; // Smaller blocks for preview\r\n\r\n    // Calculate piece dimensions\r\n    let minRow = shape.length, maxRow = 0, minCol = shape[0].length, maxCol = 0;\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                minRow = Math.min(minRow, row);\r\n                maxRow = Math.max(maxRow, row);\r\n                minCol = Math.min(minCol, col);\r\n                maxCol = Math.max(maxCol, col);\r\n            }\r\n        }\r\n    }\r\n\r\n    const pieceWidth = (maxCol - minCol + 1) * blockSize;\r\n    const pieceHeight = (maxRow - minRow + 1) * blockSize;\r\n\r\n    // Center the piece in the preview canvas\r\n    const offsetX = (previewCanvas.width - pieceWidth) / 2;\r\n    const offsetY = (previewCanvas.height - pieceHeight) / 2;\r\n\r\n    // Draw the piece\r\n    previewCtx.fillStyle = nextPiece.color;\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                const x = offsetX + (col - minCol) * blockSize;\r\n                const y = offsetY + (row - minRow) * blockSize;\r\n\r\n                previewCtx.fillRect(x, y, blockSize, blockSize);\r\n                previewCtx.strokeStyle = '#333333';\r\n                previewCtx.lineWidth = 1;\r\n                previewCtx.strokeRect(x, y, blockSize, blockSize);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Draw held piece in hold canvas\r\nfunction drawHoldPiece() {\r\n    // Clear hold canvas\r\n    holdCtx.fillStyle = '#ffffff';\r\n    holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);\r\n\r\n    if (!heldPiece) return;\r\n\r\n    const shape = heldPiece.shape;\r\n    const blockSize = 16; // Smaller blocks for preview\r\n\r\n    // Calculate piece dimensions\r\n    let minRow = shape.length, maxRow = 0, minCol = shape[0].length, maxCol = 0;\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                minRow = Math.min(minRow, row);\r\n                maxRow = Math.max(maxRow, row);\r\n                minCol = Math.min(minCol, col);\r\n                maxCol = Math.max(maxCol, col);\r\n            }\r\n        }\r\n    }\r\n\r\n    const pieceWidth = (maxCol - minCol + 1) * blockSize;\r\n    const pieceHeight = (maxRow - minRow + 1) * blockSize;\r\n\r\n    // Center the piece in the hold canvas\r\n    const offsetX = (holdCanvas.width - pieceWidth) / 2;\r\n    const offsetY = (holdCanvas.height - pieceHeight) / 2;\r\n\r\n    // Draw the piece\r\n    holdCtx.fillStyle = heldPiece.color;\r\n    for (let row = 0; row < shape.length; row++) {\r\n        for (let col = 0; col < shape[row].length; col++) {\r\n            if (shape[row][col]) {\r\n                const x = offsetX + (col - minCol) * blockSize;\r\n                const y = offsetY + (row - minRow) * blockSize;\r\n\r\n                holdCtx.fillRect(x, y, blockSize, blockSize);\r\n                holdCtx.strokeStyle = '#333333';\r\n                holdCtx.lineWidth = 1;\r\n                holdCtx.strokeRect(x, y, blockSize, blockSize);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Hold piece function\r\nfunction holdPiece() {\r\n    if (gameState.isPaused || gameState.isGameOver || !currentPiece || !canHold) {\r\n        return;\r\n    }\r\n\r\n    canHold = false;\r\n\r\n    if (heldPiece === null) {\r\n        // Store current piece and spawn next piece\r\n        heldPiece = {\r\n            shape: TETROMINO_SHAPES[currentPiece.type].rotations[0],\r\n            color: currentPiece.color,\r\n            type: currentPiece.type\r\n        };\r\n        spawnPiece();\r\n    } else {\r\n        // Swap current piece with held piece\r\n        const tempType = currentPiece.type;\r\n        const tempColor = currentPiece.color;\r\n\r\n        currentPiece = {\r\n            x: Math.floor(COLS / 2) - 2,\r\n            y: 0,\r\n            shape: heldPiece.shape,\r\n            color: heldPiece.color,\r\n            type: heldPiece.type,\r\n            rotation: 0\r\n        };\r\n\r\n        heldPiece = {\r\n            shape: TETROMINO_SHAPES[tempType].rotations[0],\r\n            color: tempColor,\r\n            type: tempType\r\n        };\r\n\r\n        // Check if spawn position is valid\r\n        if (!canMove(currentPiece.x, currentPiece.y)) {\r\n            gameState.isGameOver = true;\r\n            stopGameLoop();\r\n        }\r\n    }\r\n\r\n    drawHoldPiece();\r\n    draw();\r\n}\r\n\r\n// Start game when DOM is loaded\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', init);\r\n} else {\r\n    init();\r\n}\r\n"],"names":["canvas","ctx","previewCanvas","previewCtx","holdCanvas","holdCtx","COLS","ROWS","BLOCK_SIZE","currentPiece","nextPiece","heldPiece","canHold","board","gameState","score","level","lines","highScore","isPaused","isGameOver","gameInterval","dropSpeed","init","savedHighScore","btnLeft","btnRight","btnDown","btnRotate","btnHold","preventDefaultTouch","document","getElementById","getContext","localStorage","getItem","parseInt","Array","fill","map","generateNextPiece","spawnPiece","addEventListener","handleKeyPress","e","preventDefault","moveLeft","moveRight","moveDown","rotatePiece","holdPiece","updateUI","startGameLoop","draw","drawNextPiece","pieces","randomPiece","Math","floor","random","length","pieceData","TETROMINO_SHAPES","shape","rotations","color","type","x","y","rotation","canMove","stopGameLoop","clearInterval","max","setInterval","gameTick","lockPiece","clearLines","row","col","fullRows","every","cell","push","rows","callback","_step","originalColors","_iterator","_createForOfIteratorHelper","s","n","done","value","_toConsumableArray","err","f","flashCount","maxFlashes","flashTimer","_step2","useWhite","_iterator2","indexOf","flashRows","i","splice","unshift","setItem","toString","newLevel","textContent","event","key","nextRotation","newShape","checkCollision","_i","_wallKickOffsets","offset","newX","newY","piece","gridX","gridY","fillStyle","fillRect","width","height","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","drawGrid","strokeRect","font","textAlign","fillText","blockSize","minRow","maxRow","minCol","maxCol","min","pieceWidth","pieceHeight","offsetX","offsetY","tempType","tempColor","drawHoldPiece","readyState"],"sourceRoot":""}